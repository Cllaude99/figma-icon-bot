import fs from 'fs/promises';
import path from 'path';
import { FigmaIconBotConfig } from './types.js';

const CONFIG_FILE_NAME = '.figma-icon-bot.config.json';

export const DEFAULT_CONFIG: Partial<FigmaIconBotConfig> = {
  output: {
    directory: './icons',
    formats: ['svg'],
  },
  naming: {
    transform: 'preserve',
    sanitize: true,
  },
  git: {
    enabled: true,
    branch: 'chore/sync-figma-icons',
    commitMessage: 'chore: sync Figma icons',
    createPR: true,
    prTitle: 'ðŸŽ¨ Sync Figma Icons',
    prBody: 'This PR was automatically generated by figma-icon-bot.\n\n## Changes\n- Icons synced from Figma',
  },
  svgo: {
    enabled: true,
    plugins: [
      {
        name: 'preset-default',
        params: {
          overrides: {
            removeViewBox: false,
          },
        },
      },
      'removeDimensions',
    ],
  },
};

export async function loadConfig(cwd: string = process.cwd()): Promise<FigmaIconBotConfig> {
  const configPath = path.join(cwd, CONFIG_FILE_NAME);

  try {
    const configFile = await fs.readFile(configPath, 'utf-8');
    const userConfig = JSON.parse(configFile);

    // Merge with defaults
    const config: FigmaIconBotConfig = {
      ...DEFAULT_CONFIG,
      ...userConfig,
      figma: {
        ...userConfig.figma,
        accessToken: userConfig.figma?.accessToken || process.env.FIGMA_ACCESS_TOKEN,
      },
      output: {
        ...DEFAULT_CONFIG.output,
        ...userConfig.output,
      },
      naming: {
        ...DEFAULT_CONFIG.naming,
        ...userConfig.naming,
      },
      git: {
        ...DEFAULT_CONFIG.git,
        ...userConfig.git,
      },
      svgo: {
        ...DEFAULT_CONFIG.svgo,
        ...userConfig.svgo,
      },
    } as FigmaIconBotConfig;

    // Validate required fields
    if (!config.figma.fileKey) {
      throw new Error('figma.fileKey is required in config');
    }
    if (!config.figma.accessToken) {
      throw new Error('FIGMA_ACCESS_TOKEN environment variable or figma.accessToken in config is required');
    }

    return config;
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      throw new Error(
        `Config file not found at ${configPath}.\nRun 'figma-icon-bot init' to create one.`
      );
    }
    throw error;
  }
}

export async function createConfigFile(cwd: string = process.cwd()): Promise<void> {
  const configPath = path.join(cwd, CONFIG_FILE_NAME);

  const sampleConfig: Partial<FigmaIconBotConfig> = {
    figma: {
      fileKey: 'YOUR_FIGMA_FILE_KEY',
      nodeId: 'YOUR_FRAME_NODE_ID', // Optional: specify frame/section containing icons
      // accessToken: 'figd_...', // Or use FIGMA_ACCESS_TOKEN env var
    },
    output: {
      directory: './icons',
      formats: ['svg', 'react'],
      react: {
        typescript: true,
        exportType: 'named',
        componentPrefix: 'Icon',
      },
    },
    naming: {
      transform: 'preserve', // 'preserve' | 'kebab-case' | 'camelCase' | 'PascalCase'
      sanitize: true, // Remove filesystem-unsafe characters
    },
    git: {
      enabled: true,
      branch: 'chore/sync-figma-icons',
      commitMessage: 'chore: sync Figma icons',
      createPR: true,
      prTitle: 'ðŸŽ¨ Sync Figma Icons',
      prBody: 'This PR was automatically generated by figma-icon-bot.',
    },
    filters: {
      // includePattern: '^icon-',
      // excludePattern: '^_',
    },
    svgo: {
      enabled: true,
    },
  };

  await fs.writeFile(configPath, JSON.stringify(sampleConfig, null, 2), 'utf-8');
}
